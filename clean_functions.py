# -*- coding: utf-8 -*-
"""clean_functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bx81itTpM0e3P7DZxX3AXzptsOjElZlh
"""

import pandas as pd
import numpy as np
import re
import random
from datetime import datetime, timedelta
from collections import Counter

start_time = pd.to_datetime('07:00:00 AM', format='%I:%M:%S %p').time()
end_time = pd.to_datetime('11:00:00 PM', format='%I:%M:%S %p').time()
def adjust_time_in_range(time):
    if pd.isnull(time):
        return None
    elif not (start_time <= time.time() <= end_time):
        # Swap AM/PM to bring time in the desired range
        adjusted_time = (time + pd.Timedelta(hours=12)) if time.time() < start_time else (time - pd.Timedelta(hours=12))
        return adjusted_time.time()
    else:
        return time.time()

def filter_days(day_of_trip, travel_days):
  random.seed(2020)
  if isinstance(day_of_trip, float) and np.isnan(day_of_trip):
  # if day_of_trip is None or day_of_trip.count(None) >0:
    return None
  # Ensure travel_days is a valid list
  if isinstance(travel_days, list) and len(travel_days) > 0:
      # Keep only valid days from day_of_trip
      # print(day_of_trip)
      valid_days = [day for day in day_of_trip if day in travel_days]

      # Ensure at least one valid day is retained
      if not valid_days:
          # If no valid days left, choose one day from travel_days
          valid_days = [random.choice(travel_days)]
      return valid_days
  else:
      # If travel_days is not a list or invalid, return None
      return None

def check_time_in_range(travel_hours, actual_time):
    random.seed(2020)
    # Check if time_start is NaN
    if pd.isnull(actual_time):
        return None

    # Split travel_hours into individual time ranges
    time_ranges = travel_hours.split(', ')
    valid_ranges = []
    time_ranges = travel_hours.split(', ')  # Split string into individual time ranges

    for time_range in time_ranges:
        start_str, end_str = time_range.split(' - ')  # Split each range into start and end times
        start_time = datetime.strptime(start_str, '%H%M').time()  # Convert to time object
        end_time = datetime.strptime(end_str, '%H%M').time()  # Convert to time object
        # Add to valid ranges list
        valid_ranges.append((start_time, end_time))

        # Check if the actual_time falls within the current range
        if start_time <= actual_time <= end_time:
            return actual_time

    # If the actual_time is not in any valid range, pick a random time from travel_hours
    random_range = random.choice(valid_ranges)  # Select a random valid range
    random_start, random_end = random_range

    # Generate a random time within the selected range
    delta = (datetime.combine(datetime.today(), random_end) - datetime.combine(datetime.today(), random_start)).seconds
    random_seconds = random.randint(0, delta)
    random_time = (datetime.combine(datetime.today(), random_start) + timedelta(seconds=random_seconds)).time()
    return random_time

# ADDITIONAL FEATURES
# Function to convert integer to ordinal form
def int_to_ordinal(rank):
        if isinstance(rank, int):
            if rank == 1:
                return '1st'
            elif rank == 2:
                return '2nd'
            elif rank == 3:
                return '3rd'
            elif rank == 4:
                return '4th'
            elif rank == 5:
                return '5th'
            elif rank == 6:
              return '6th'
        return rank

# Function to determine ranking distribution across all rows
def calculate_rank_distribution(data, columns):
    distribution = {}
    for col in columns:
        rank_counts = Counter(data[col])
        distribution[col] = dict(rank_counts)
    return distribution

# Function to check for duplicate rankings and replace them based on other responses
def check_ranking(row, distribution, ranks):
    # Convert ranking values to integers
    rankings = [int(rank[0]) if isinstance(rank, str) else rank for rank in row]

    # Check if duplicates exist
    duplicates = {rank for rank in rankings if rankings.count(rank) > 1}

    # If duplicates are found, replace the row based on distribution
    if duplicates:
        used_ranks = set()
        replacement_ranks = []

        # Select unique ranks for each column
        for col_name in row.index:
            # Find the most frequent unused rank for the column
            for rank in sorted(ranks, key=lambda r: distribution[col_name].get(r, 0), reverse=True):
                if rank not in used_ranks:
                    replacement_ranks.append(rank)
                    used_ranks.add(rank)
                    break

        # Convert integers back to ordinal format
        return [int_to_ordinal(rank) for rank in replacement_ranks]
    else:
        # If no duplicates, return the original row as ordinal values
        return [int_to_ordinal(rank) for rank in rankings]

# Apply the function to each group of rankings in the DataFrame
def apply_rank_fix(data, columns, ranks):
    # Calculate rank distribution based on existing data
    rank_distribution = calculate_rank_distribution(data, columns)

    # Apply the replace_with_unique_distribution function to rows
    data[columns] = data[columns].apply(lambda row: check_ranking(
        row, rank_distribution, ranks), axis=1, result_type='expand')
    return data

def update_trips(data):
    for i in range(2, 4):  # Iterating through trip 2 and trip 3 since trip 1 is compulsory
        service_col = f'ISB_Service_trip_{i}'
        trip_cols = [
            f'bus_stop_board_trip_{i}', f'bus_stop_alight_trip_{i}',
            f'day_of_the_week_trip_{i}', f'time_start_trip_{i}',
            f'travel_duration_trip_{i}', f'frequency_trip_{i}',
            f'punctuality_trip_{i}', f'cleanliness_trip_{i}',
            f'safety_trip_{i}', f'coverage_trip_{i}', f'crowdedness_trip_{i}'
        ]

        # Apply condition to replace columns with "No trip" if service column is NaN
        data.loc[data[service_col].isna(), [service_col] + trip_cols] = "No trip"

    return data

def identify_na_rows_excluding_last_two(data):
    # Select all columns except the last two
    columns_to_check = data.columns[:-2]

    # Identify rows with NaN values in any of the specified columns
    na_rows = data[data[columns_to_check].isna().any(axis=1)]
    return na_rows

def validate_bus_stops(data, bus_routes):
    for i in range(1, 4):  # Loop through each trip
        service_col = f'ISB_Service_trip_{i}'
        board_col = f'bus_stop_board_trip_{i}'
        alight_col = f'bus_stop_alight_trip_{i}'

        def check_stops(row):
            random.seed(2020)
            bus = row[service_col]
            start = row[board_col]
            end = row[alight_col]

            # Check for "No trip"
            if bus == "No trip":
              return bus, start, end  # Return as is

            # Get the route for the bus
            route = bus_routes.get(bus, [])

            if start in route and end in route:
                start_index = route.index(start)
                end_index = route.index(end) if end != route[0] else len(route)

                if start_index < end_index and start != end:
                    return bus, start, end  # No change if valid

            # If only start is valid, randomly select an end stop from the route after start
            if start in route:
                start_index = route.index(start)
                if start_index < len(route) - 1:  # Ensure there are stops after start
                    possible_ends = route[start_index + 1:]
                    new_end = np.random.choice(possible_ends)
                    while new_end == start:
                        new_end = np.random.choice(possible_ends)
                    return bus, start, new_end

            # If only end is valid, select a new start stop before end
            if end in route:
                end_index = route.index(end)
                if end_index == 0:
                    end_index = len(route) - 1  # If end is the first stop, assume it is the last stop (loop)
                if end_index > 0:
                    possible_starts = route[:end_index]
                    new_start = np.random.choice(possible_starts)
                    while new_start == end:
                        new_start = np.random.choice(possible_starts)
                    return bus, new_start, end

            # Check for valid buses that have both start and end in the route
            valid_buses = [
                key for key, route in bus_routes.items()
                if start in route and end in route and
                (route.index(start) < route.index(end) or
                 (route.index(end) == 0 and route.index(start) < len(route) - 1))
            ]
            if valid_buses:
                new_bus = np.random.choice(valid_buses)  # Randomly choose one valid bus
                return new_bus, start, end

            # else, select two random stops in the correct order from the current bus route
            random_start_index = np.random.randint(0, len(route) - 1)
            random_end_index = np.random.randint(random_start_index + 1, len(route))
            while random_start_index == 0 and random_end_index == len(route) - 1:
                random_end_index = np.random.randint(random_start_index + 1, len(route))
            new_start = route[random_start_index]
            new_end = route[random_end_index]
            return bus, new_start, new_end

        data[[service_col, board_col, alight_col]] = data.apply(lambda row: check_stops(row), axis=1, result_type="expand")

    return data

# Change bus_stop_board and bus_stop_alight to "error" if there is error in bus route
def check_validate_bus_stops(data, bus_routes):
    for i in range(1, 4):  # Loop through each trip
        service_col = f'ISB_Service_trip_{i}'
        board_col = f'bus_stop_board_trip_{i}'
        alight_col = f'bus_stop_alight_trip_{i}'

        def check_stops(row):
            bus = row[service_col]
            start = row[board_col]
            end = row[alight_col]

            if bus == "No trip":
              return row[board_col], row[alight_col]

            # Check if bus route exists in the dictionary
            if bus in bus_routes:
                route = bus_routes[bus]

                # Check both stops are in the route and start is before end
                if start in route and end in route:
                    start_index = route.index(start)
                    # Handle looping
                    end_index = route.index(end) if end != route[0] else len(route)

                    if start_index < end_index:
                        return row[board_col], row[alight_col]  # No change if valid
            return "error", "error"
        data[[board_col, alight_col]] = data.apply(lambda row: check_stops(row), axis=1, result_type="expand")

    return data